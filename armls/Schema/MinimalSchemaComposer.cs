using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Schema;

namespace Armls.Schema;

/// <summary>
/// Composes minimal ARM template schemas by filtering the deploymentTemplate.json schema
/// to only reference the resource schemas actually used in the template.
/// This allows JSON.NET to download only 3-5 schemas instead of 1,300+.
/// </summary>
public class MinimalSchemaComposer
{
    private readonly Dictionary<string, string> schemaJsonCache;
    private readonly HttpClient httpClient;
    private readonly string schemaDirectory = "/Users/samvidmistry/Downloads/schemas";
    private readonly Dictionary<string, string> schemaIndex;

    public MinimalSchemaComposer()
    {
        schemaJsonCache = new();
        httpClient = new();
        var indexPath = Path.Combine(schemaDirectory, "schema_index.json");
        var indexJson = File.ReadAllText(indexPath);
        schemaIndex =
            JsonConvert.DeserializeObject<Dictionary<string, string>>(indexJson)
            ?? new Dictionary<string, string>();
    }

    /// <summary>
    /// Creates a minimal schema by downloading the full deploymentTemplate.json schema from the internet,
    /// filtering its resource references to only include detected resource types,
    /// and using a preloaded resolver with provider schemas loaded from local files.
    /// </summary>
    public async Task<JSchema?> ComposeSchemaAsync(
        string baseSchemaUrl,
        Dictionary<string, string> resourceTypesWithVersions
    )
    {
        // Download the base deploymentTemplate.json schema from the internet
        if (!schemaJsonCache.TryGetValue(baseSchemaUrl, out var cachedSchemaJson))
        {
            schemaJsonCache[baseSchemaUrl] = await httpClient.GetStringAsync(baseSchemaUrl);
        }

        var baseSchemaJson = schemaJsonCache[baseSchemaUrl];

        // Create preloaded resolver with provider schemas loaded from local files
        var resolver = new JSchemaPreloadedResolver();

        // Create schema URLs only for referred/used resources
        var schemaUrls = new HashSet<string>();

        foreach (var kvp in resourceTypesWithVersions)
        {
            var resourceType = kvp.Key;
            var apiVersion = kvp.Value;

            // Split resource type: Microsoft.Storage/storageAccounts -> ["Microsoft.Storage", "storageAccounts"]
            var parts = resourceType.Split('/');
            if (parts.Length < 2)
                continue;

            var provider = parts[0]; // "Microsoft.Storage"

            // Generate base schema URL (without the fragment)
            // Pattern: https://schema.management.azure.com/schemas/2021-04-01/Microsoft.Storage.json
            schemaUrls.Add(
                $"https://schema.management.azure.com/schemas/{apiVersion}/{provider}.json"
            );
        }

        // Always include the common definitions
        schemaUrls.Add("https://schema.management.azure.com/schemas/common/definitions.json");

        // Load each provider schema from local files and add to resolver
        foreach (var schemaUrl in schemaUrls)
        {
            if (!schemaIndex.TryGetValue(schemaUrl, out var filename))
            {
                continue;
            }

            var filePath = Path.Combine(schemaDirectory, filename);
            if (!File.Exists(filePath))
            {
                continue;
            }

            var schemaContent = await File.ReadAllTextAsync(filePath);
            if (schemaContent != null)
            {
                resolver.Add(new Uri(schemaUrl), schemaContent);
            }
        }

        // Filter the schema to only reference needed resource types
        var minimalSchemaJson = ConstructSchemaWithResources(
            baseSchemaJson,
            resourceTypesWithVersions
        );

        if (minimalSchemaJson is null)
        {
            return null;
        }

        // Load schema using preloaded resolver (provider schemas from local files)
        using var minimalReader = new JsonTextReader(new StringReader(minimalSchemaJson));

        return JSchema.Load(minimalReader, resolver);
    }

    /// <summary>
    /// Generates a minimal deploymentTemplate.json schema by:
    /// 1. Replacing the 1300+ references in branch 0 with only our detected resource types
    /// 2. Removing the autogeneratedResources.json reference (branch 3)
    /// 3. Keeping branches 1 and 2 intact for external and deployment resources
    /// </summary>
    private string? ConstructSchemaWithResources(
        string baseSchemaJson,
        Dictionary<string, string> resourceTypesWithVersions
    )
    {
        try
        {
            var schemaObj = JObject.Parse(baseSchemaJson);

            // Navigate to: definitions.resource.oneOf
            // Structure: [branch0, branch1, branch2, autogeneratedResources]
            var resourceDefinition = schemaObj["definitions"]?["resource"];
            var oneOfArray = resourceDefinition?["oneOf"] as JArray;

            if (oneOfArray == null || oneOfArray.Count < 4)
            {
                return baseSchemaJson;
            }

            // Branch 0: allOf[resourceBase, {oneOf: [1300+ refs]}] - Replace with minimal refs
            var branch0 = oneOfArray[0] as JObject;
            var allOfArray = branch0?["allOf"] as JArray;
            var secondAllOf = allOfArray?[1] as JObject;
            var resourceRefsArray = secondAllOf?["oneOf"] as JArray;

            if (resourceRefsArray != null)
            {
                // Replace with our minimal references
                var minimalRefs = GenerateResourceReferences(resourceTypesWithVersions);
                secondAllOf["oneOf"] = minimalRefs;
            }

            // Branch 1: Remove external resources
            oneOfArray.RemoveAt(1);

            // Branch 2: Remove deployment resources
            oneOfArray.RemoveAt(1);

            // Branch 3: Remove autogeneratedResources reference
            oneOfArray.RemoveAt(1);

            return schemaObj.ToString();
        }
        catch (Exception ex)
        {
            // Return original schema if generation fails
            return null;
        }
    }

    /// <summary>
    /// Generates schema reference objects for the detected resource types.
    /// Uses the pattern: https://schema.management.azure.com/schemas/{apiVersion}/{provider}.json#/resourceDefinitions/{resourceName}
    /// </summary>
    private static JArray GenerateResourceReferences(
        Dictionary<string, string> resourceTypesWithVersions
    )
    {
        var references = new JArray();

        foreach (var kvp in resourceTypesWithVersions)
        {
            var resourceType = kvp.Key;
            var apiVersion = kvp.Value;

            // Split resource type: Microsoft.Storage/storageAccounts -> ["Microsoft.Storage", "storageAccounts"]
            var parts = resourceType.Split('/');
            if (parts.Length < 2)
                continue;

            var provider = parts[0]; // "Microsoft.Storage"
            var resourceName = parts[1]; // "storageAccounts"

            // Generate schema URL using the actual API version from the ARM template
            // Pattern: https://schema.management.azure.com/schemas/2021-04-01/Microsoft.Storage.json#/resourceDefinitions/storageAccounts
            var schemaUrl =
                $"https://schema.management.azure.com/schemas/{apiVersion}/{provider}.json#/resourceDefinitions/{resourceName}";

            // Create reference object
            var refObject = new JObject { ["$ref"] = schemaUrl };

            references.Add(refObject);
        }

        return references;
    }
}
